import numpy as np
from numpy.linalg import inv
import itertools
np.random.seed(4)

#Diffie-Hellman key exchange.

#Public information:
N = 2017    #The order of the group.
g = 19      #The generator (base)

#Private information:
x_1 = 113    #Alice's power
x_2 = 57    #Bob's power

#Transmitted information:
transmitted1 = g**x_1 % N    #From Alice to Bob
transmitted2 = g**x_2 % N    #From Bob to Alice
shared_message = int(transmitted2**x_1 % N)    #The shared secret

#Converting the shared secret to a binary sequence:
binary_secret=[]
while True:
	binary_secret=[shared_message%2]+binary_secret
	shared_message=shared_message/2
	if shared_message==0:
		break

########################################################################

#I will construct a finite field F=GF(2^11).
#Each element in F can be represented as a sequence of 11 binary digits
#The additive identity in F is [0,0,0,0,0,0,0,0,0,0,0]
#The multiplicative identity in F is [0,0,0,0,0,0,0,0,0,0,1]
#I will chose F such that alpha = [0,0,0,0,0,0,0,0,0,1,0] is a generator
#F = GF(2)[x] / < p(x) >, where < p(x) > is the ideal generated by a
#polynomial p(x) of degree 11. I record the coefficients of p(x) in c.
#alpha is a root of p(z) in F.

#The following function takes c (which specifies the field F) and n
#(an element of F), and outputs alpha*n in F.
def multiply_by_alpha(c,n):
	if len(c)!=len(n):
		return "Length of n should equal the length of c!"
	result=[0 for i in range(len(c))]    #result is empty initially

	for i in range(len(c)-1):
		result[i]=n[i+1]        #shifting by one position and recording

	if n[0]==1:
		for i in range(len(n)):
			result[i]=(result[i]+c[i])%2
			#If I get alpha*(alpha)^10=alpha^11=p(alpha)+alpha^11,
			#I add the current result to this expression modulo 2

	return result

#The following function outputs (n1 XOR n2) as a list.
def xor_lists(n1,n2):
	if len(n1)!=len(n2):
		return "Length of n1 should equal the length of n2!"
	return [(n1[i]+n2[i])%2 for i in range(len(n1))]

#The following function takes two lists and multiplies them componentwise.
def multiply_lists(n1,n2):
	if len(n1)!=len(n2):
		return "Length of n1 should equal the length of n2!"
	return [n1[i]*n2[i] for i in range(len(n1))]

#The following function takes two elements of F and multiplies them in F.
def multiply(c,n1,n2):
	if len(n1)!=len(n2) or len(c)!=len(n1) or len(c)!=len(n2):
		return "Lengths not equal!"

	length = len(n2)
	result = [0 for i in range(length)]    #result is empty initially
	temp_result=[0 for i in range(length)] #for each small multiplication

	for i in range(length):
		if n2[i]==1:                       #For each nonzero element in n2
			temp_result = [j for j in n1]  #A copy of n1
			for j in range(length-i-1):
				#Multiplying n1 by alpha k times if the nonzero
				#element in n2 corresponds to alpha^k
				temp_result = multiply_by_alpha(c,temp_result)
		result = xor_lists(result,temp_result)   #Adding to the result
		temp_result=[0 for j in range(length)]   #temp_result back to zero

	return result

#c defines F = GF(2)[x] / < p(x) > by specifying the coefficients of p(x):

def choose_c():
	while True:

		#This part ensures c is chosen such that 0 and 1 are not roots of p(x)
		while True:
			c=np.random.randint(2,size=10) #choosing the first 10 bits randomly
			c=np.append(c,[1])             #Last bit=1 ensures that p(0)=1
			if sum(c)%2==0:                #Refusing to take c, such that p(1)=0
				break

		#This part ensures that alpha is a multiplicative generator of F.
		#This guarantees that the period is as large as possible (2^11-1).
		one = [0,0,0,0,0,0,0,0,0,0,1]
		found=False
		for i in range(2046):
			one=multiply_by_alpha(c,one)
			if one==[0,0,0,0,0,0,0,0,0,0,1]:   #Checking for alpha^k = one.
				found=True
		if found==True:
			continue                #If alpha^k = one was found, try again
		break
	return c

c = choose_c()
#The chosen c is [0,0,1,1,0,1,1,1,0,0,1] = [c_{10},c_9,c_8,...,c_1,c_0]
#, which corresponds to the following polynomial: p(x) = x^11 + x^8 + x^7 + x^5 + x^4 + x^3 + 1.

#This part uses brute force to solve a linear system of equations is GF(2):
#matrix*vector1 = vector2. The function checks if vector1 is a solution.
def check_matrix_equation(matrix, vector1, vector2):
	vector3 = [[matrix.dot(vector1)[i]%2] for i in range(len(vector1))]
	equal = True
	for i in range(len(vector3)):
		if vector3[i] != vector2[i]:
			equal = False
	return equal

#The following function takes an element n of F and outputs its trace.
def find_trace(c,n):
	if len(c)!=len(n):
		return "Length of n should equal the length of c!"

	result = [0 for i in range(len(n))]    #result is empty initially
	for i in range(len(n)):
		copy_of_n = [j for j in n]         #A copy of n

		#I need to take n^{2^i}, so I multiply the copy_of_n by itself i times
		for k in range(i):
			copy_of_n = multiply(c,copy_of_n,copy_of_n)
		result = xor_lists(result,copy_of_n)  #Adding the result to the total

	return result[-1]  #The result is [0,0,...,0] (Tr=0) or [0,0,...,1] (Tr=1)

#The following function records the traces of: the multiplicative identity,
#alpha, alpha^2, ..., alpha^{2*11-2}
#These traces can help us use the initial conditions to find the solution
def record_traces(c):
	traces=[]
	for i in range(2*len(c)-1):
		multiplier = [0 for j in range(len(c)-1)] + [1]    #The mult. identity
		
		for j in range(i):                        #Multiplying alpha by itself
			multiplier = multiply_by_alpha(c, multiplier)

		traces.append(find_trace(c,multiplier))  #Append the trace to the list
	return traces

traces = record_traces(c)

#If s_t = Tr(b_0*(alpha)^t), then s_0 = Tr(b_0). Writing b_0 in the basis
#[1,alpha,alpha^2,...,alpha^(10)] yields the first equation. Similarly,
#s_1 = Tr(b_0*alpha) yields the second one, etc.

#The shared binary secret as a column vector:
#It generates the keystream, thus it is S_0=[s_0,s_1,...,s_10].
vector_bin_secret = np.array([[i] for i in binary_secret])

#Arrenging the traces of the powers of alpha into a matrix:
matrix_traces = np.array([[traces[i+j] for j in range(len(c))] for i in range(len(c))])

#Solving the system of linear equations modulo 2:
#These are the coefficients of b_0 written in the basis [1,alpha,...,alpha^(10)]

#This is a list of all 2048 binary sequences of length 11: all the candidate solutions.
all_binary_sequences = [[int(seq[i]) for i in range(len(c))] for seq in itertools.product("01", repeat=len(c))]

for i in range(2**len(c)):    #Checking if each such sequence is a solution:
	result_guess=[[all_binary_sequences[i][j]] for j in range(len(c))]
	if check_matrix_equation(matrix_traces, result_guess, vector_bin_secret):
		result = [result_guess[i][0] for i in range(len(result_guess))][::-1]

#The following function takes an element result and finds i: alpha^i=result
def find_power_of_alpha(c, result):
	one = [0,0,0,0,0,0,0,0,0,0,1]    #The multiplicative identity

	#The size of the multiplicative group of F is 2^11-1=2047
	for i in range(2046):
		one = multiply_by_alpha(c,one)
		if one == result:    #Multiplying by alpha and checking
			i_match = i+1
			break            #Break when found

	return i_match

i_match = find_power_of_alpha(c, result)
print "I calculated that if s_t = Tr( alpha^{t+k} ), then k =", i_match

#Suppose Alice sends to Bob the following message:
message_words = "This is a wrong message"

#Converting the message into a list of bits:
message = [int(i) for j in [format(ord(x), 'b') for x in message_words] for i in j]

alpha_plus_1 = [0,0,0,0,0,0,0,0,0,1,1]
z = [i for i in binary_secret]         #Because z_i = f(k,s_i) = s_i

#I will calculate s_{t+n} = sum_i c_i*s_{t+i} and for this I need [c_0, ..., c_{10}]
#instead of the current c = [c_{10},c_9,...,c_1,c_0].
c_reversed = c[::-1]

#Generating the keystream:
for i in range(len(message)):
	if i>=len(binary_secret):
		z.append(sum(multiply_lists(c_reversed,z[i-len(binary_secret):i]))%2)

#Generating the ciphertext:
ciphertext = [(message[i]+z[i])%2 for i in range(len(message))]

#Eve gets the ciphertext and realizes she needs to correctly guess the first
#three letters to break the cipher. Her best guess is 'The'. She is wrong: it is 'Thi'.
guess_words = "The"

#Converting the guess into a list of bits:
guess = [ int(j) for i in [format(ord(x), 'b') for x in guess_words] for j in i] + [1]

#This is what the beginning of z would look like assuming the guess was correct:
guess_for_z = [(guess[i]+ciphertext[i])%2 for i in range(len(guess))]

#Eve now has 11 linear equations with 11 unknowns c = [c_{10},...,c_0]. She sets up the system:
LHS_matrix_guess = np.array([[guess_for_z[i+j] for j in range(len(c))] for i in range(len(c))])
RHS_vector_guess = np.array([[guess_for_z[len(c)+i]] for i in range(len(c))])

#This is a list of all 2048 binary sequences of length 11: all the candidate solutions.
all_binary_sequences = [[int(seq[i]) for i in range(len(c))] for seq in itertools.product("01", repeat=len(c))]

for i in range(2**len(c)):    #Checking if each such sequence is a solution:
	result_guess=[[all_binary_sequences[i][j]] for j in range(len(c))]
	if check_matrix_equation(LHS_matrix_guess, result_guess, RHS_vector_guess):
		guess_c = [result_guess[i][0] for i in range(len(result_guess))]


#Generating the rest of the keystream:
guess_for_z_new = guess_for_z[0:len(c)]
length = len(guess_for_z_new)
for i in range(len(message)):
	if i >= length:
		guess_for_z_new.append(sum(multiply_lists(guess_c, guess_for_z_new[i-length:i]))%2)

#Using the generated keystream to decrypt:
message_binary_decrypted = xor_lists(guess_for_z_new,ciphertext)

#Transforming the binary into text:
string=[]
answer=[]
for i in range(len(message_binary_decrypted)):
	string.append(str(message_binary_decrypted[i]))

	if len(string) == 6:
		if string == ['1','0','0','0','0','0']:   #Catching empty space
			string = []
			answer.append(' ')

	if len(string) == 7:
		string = ''.join(string)
		answer.append(chr(int(string, 2)))
		string = []
print "The decrypted message is:"
print ''.join(answer)
print "As expected, it is nonsensical, hence the 'The' guess was incorrect."




#Now suppose Alice sends to Bob the following message:
message_words = "The weather is fine"

#Converting the message into a list of bits:
message = [int(i) for j in [format(ord(x), 'b') for x in message_words] for i in j]

alpha_plus_1 = [0,0,0,0,0,0,0,0,0,1,1]
z = [i for i in binary_secret]         #Because z_i = f(k,s_i) = s_i

#I will calculate s_{t+n} = sum_i c_i*s_{t+i} and for this I need [c_0, ..., c_{10}]
#instead of the current c = [c_{10},c_9,...,c_1,c_0].
c_reversed = c[::-1]

#Generating the keystream:
for i in range(len(message)):
	if i >= len(binary_secret):
		z.append(sum(multiply_lists(c_reversed,z[i-len(binary_secret):i]))%2)

#Generating the ciphertext:
ciphertext = [(message[i]+z[i])%2 for i in range(len(message))]

#Eve gets the ciphertext and realizes she needs to correctly guess the first
#three letters to break the cipher. Her best guess is 'The'. She is wrong: it is 'Thi'.
guess_words = "The"

#Converting the guess into a list of bits:
guess = [ int(j) for i in [format(ord(x), 'b') for x in guess_words] for j in i] + [1]

#This is what the beginning of z would look like assuming the guess was correct:
guess_for_z = [(guess[i]+ciphertext[i])%2 for i in range(len(guess))]

#Eve now has 11 linear equations with 11 unknowns c = [c_{10},...,c_0]. She sets up the system:
LHS_matrix_guess = np.array([[guess_for_z[i+j] for j in range(len(c))] for i in range(len(c))])
RHS_vector_guess = np.array([[guess_for_z[len(c)+i]] for i in range(len(c))])

#This is a list of all 2048 binary sequences of length 11: all the candidate solutions.
all_binary_sequences = [[int(seq[i]) for i in range(len(c))] for seq in itertools.product("01", repeat=len(c))]

for i in range(2**len(c)):    #Checking if each such sequence is a solution:
	result_guess=[[all_binary_sequences[i][j]] for j in range(len(c))]
	if check_matrix_equation(LHS_matrix_guess, result_guess, RHS_vector_guess):
		guess_c = [result_guess[i][0] for i in range(len(result_guess))]

#Generating the rest of the keystream:
guess_for_z_new = guess_for_z[0:len(c)]
length = len(guess_for_z_new)
for i in range(len(message)):
	if i >= length:
		guess_for_z_new.append(sum(multiply_lists(guess_c,guess_for_z_new[i-length:i]))%2)

#Using the generated keystream to decrypt:
message_binary_decrypted = xor_lists(guess_for_z_new,ciphertext)

#Transforming the binary into text:
string = []
answer = []
for i in range(len(message_binary_decrypted)):
	string.append(str(message_binary_decrypted[i]))

	if len(string) == 6:
		if string == ['1','0','0','0','0','0']:   #Catching empty space
			string = []
			answer.append(' ')

	if len(string) == 7:
		string = ''.join(string)
		answer.append(chr(int(string, 2)))
		string = []
print "The decrypted message is:"
print ''.join(answer)
print "As expected, it is the correct message. Security was broken!"
